var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides detailed documentation for all exported functions and types in ChenSignatures.jl.","category":"section"},{"location":"api/#Primary-Functions","page":"API Reference","title":"Primary Functions","text":"These are the main user-facing functions for computing signatures and log-signatures:","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Lower-Level-API","page":"API Reference","title":"Lower-Level API","text":"Advanced users may need direct access to tensor-based computations:","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"Pages = [\"api.md\"]","category":"section"},{"location":"api/#ChenSignatures.sig","page":"API Reference","title":"ChenSignatures.sig","text":"sig(path::AbstractMatrix, m::Int) -> Vector\n\nCompute the truncated path signature up to level m.\n\nThe path signature is a graded feature vector that characterizes the path's geometry. It consists of iterated integrals computed recursively using Chen's identity.\n\nArguments\n\npath::AbstractMatrix{T}: N×d matrix where N ≥ 2 is the number of points and d ≥ 1 is the dimension. Each row represents a point in d-dimensional space.\nm::Int: Truncation level (m ≥ 1). The signature will include levels 1 through m.\n\nReturns\n\nVector{T}: Flattened coefficient vector of length d + d² + ... + dᵐ containing signature coefficients ordered by level (all level-1 terms, then level-2, etc.).\n\nComputational Complexity\n\nTime: O(N · dᵐ⁺¹) where N is path length\nSpace: O(dᵐ⁺¹) for signature storage\n\nExamples\n\n# 2D path with 100 points, signature up to level 3\npath = randn(100, 2)\ns = sig(path, 3)\nlength(s)  # 2 + 4 + 8 = 14\n\n# 3D path, level 4\npath = randn(50, 3)\ns = sig(path, 4)\nlength(s)  # 3 + 9 + 27 + 81 = 120\n\nNotes\n\nThis function allocates scratch buffers internally. For repeated calls, consider using signature_path! with a preallocated SignatureWorkspace.\nFor log-signature (more compact representation), see logsig.\n\nReferences\n\nK.T. Chen (1957). \"Integration of paths, geometric invariants and a generalized Baker-Hausdorff formula.\"\n\nSee also: logsig, prepare, signature_path!\n\n\n\n\n\nsig(paths::AbstractArray{T,3}, m::Int; threaded::Bool=true) -> Matrix{T}\n\nCompute truncated path signatures for a batch of paths.\n\nArguments\n\npaths::AbstractArray{T,3}: N×D×B array where:\nN ≥ 2: number of time points per path\nD ≥ 1: spatial dimension\nB ≥ 1: batch size (number of paths)\nm::Int: Truncation level (m ≥ 1)\nthreaded::Bool=true: Use multi-threading when true\n\nReturns\n\nMatrix{T}: S×B matrix where S = d + d² + ... + dᵐ (signature length) and each column result[:, i] contains the signature of paths[:, :, i]\n\nComputational Complexity\n\nTime: O(B · N · dᵐ⁺¹) where B is batch size, N is path length\nSpace: O(B · dᵐ⁺¹) for output storage\nThreading: Near-linear speedup with number of threads for large batches\n\nExamples\n\n# Batch of 100 paths, each with 50 time points in 3D space\npaths = randn(50, 3, 100)\nsigs = sig(paths, 4)  # Returns 120×100 matrix\nsize(sigs)  # (120, 100)\n\n# Access signature of the 5th path\nsig_5 = sigs[:, 5]\n\n# Disable threading for small batches\nsigs = sig(paths, 4; threaded=false)\n\nPerformance Notes\n\nUses Threads.@threads when threaded=true (default)\nThreading overhead may not be worth it for very small batches (B < 10)\nFor maximum performance with manual workspace management, see signature_path!\n\nSee also: sig, logsig, SignatureWorkspace\n\n\n\n\n\n","category":"function"},{"location":"api/#ChenSignatures.logsig","page":"API Reference","title":"ChenSignatures.logsig","text":"logsig(path::AbstractMatrix, basis::BasisCache) -> Vector\n\nCompute the log-signature of a path projected onto the Lyndon basis.\n\nThe log-signature is the logarithm (in the tensor algebra) of the signature, and provides a more compact representation. When projected onto the Lyndon basis, it gives coefficients in the free Lie algebra, which is much smaller than the full tensor algebra.\n\nArguments\n\npath::AbstractMatrix{T}: N×d matrix where N ≥ 2 is the number of points. Dimension d must match the basis.\nbasis::BasisCache: Precomputed basis from prepare(d, m)\n\nReturns\n\nVector{T}: Log-signature coefficients in Lyndon basis. Length equals number of Lyndon words up to length m.\n\nComputational Complexity\n\nTime: O(N · dᵐ⁺¹ + L²) where L is number of Lyndon words\nSpace: O(dᵐ⁺¹) for intermediate signature computation\n\nExamples\n\n# Setup\npath = randn(100, 3)\nbasis = prepare(3, 4)\n\n# Compute log-signature\nls = logsig(path, basis)\n\n# Log-signature is much more compact than signature\nprintln(\"Log-signature size: \", length(ls))        # Depends on Lyndon words\nprintln(\"Full signature size: \", 3 + 9 + 27 + 81)  # 120\n\nNotes\n\nRequires precomputed basis from prepare.\nMore compact than sig but requires additional preprocessing.\nBest suited when you need many log-signatures with the same (d, m).\n\nReferences\n\nLyons, Caruana, Lévy (2007). \"Differential equations driven by rough paths.\" Lecture Notes in Mathematics.\n\nSee also: sig, prepare, BasisCache\n\n\n\n\n\nlogsig(paths::AbstractArray{T,3}, basis::BasisCache; threaded::Bool=true) -> Matrix{T}\n\nCompute log-signatures for a batch of paths using a precomputed Lyndon basis.\n\nArguments\n\npaths::AbstractArray{T,3}: N×D×B array of paths where:\nN ≥ 2: number of time points per path\nD ≥ 1: spatial dimension (must match basis)\nB ≥ 1: batch size (number of paths)\nbasis::BasisCache: Precomputed basis from prepare(D, m)\nthreaded::Bool=true: Use multi-threading when true\n\nReturns\n\nMatrix{T}: L×B matrix where L is the number of Lyndon words and each column result[:, i] contains the log-signature of paths[:, :, i]\n\nComputational Complexity\n\nTime: O(B · (N · dᵐ⁺¹ + L²)) where L is number of Lyndon words\nSpace: O(B · L) for output storage\nLog-signature dimension L is much smaller than signature dimension\n\nExamples\n\n# Precompute basis once for 3D paths, level 4\nbasis = prepare(3, 4)\n\n# Process batch of 100 paths\npaths = randn(50, 3, 100)\nlogsigs = logsig(paths, basis)\n\n# Log-signature is more compact than signature\nprintln(\"Log-signature size: \", size(logsigs, 1))  # Much less than 120\nprintln(\"Number of paths: \", size(logsigs, 2))     # 100\n\n# Process another batch with same basis\nmore_paths = randn(50, 3, 50)\nmore_logsigs = logsig(more_paths, basis)\n\nPerformance Notes\n\nPrecompute and reuse basis for all batches with the same (D, m)\nThreading provides significant speedup for large batches\nMore memory-efficient than sig due to compact representation\n\nSee also: logsig, sig, prepare, BasisCache\n\n\n\n\n\n","category":"function"},{"location":"api/#ChenSignatures.prepare","page":"API Reference","title":"ChenSignatures.prepare","text":"prepare(d::Int, m::Int) -> BasisCache\n\nPrecompute Lyndon basis and projection matrix for log-signature computation.\n\nThis function builds the data structures needed for logsig. The Lyndon basis provides a Hall basis for the free Lie algebra, giving a minimal representation of the log-signature with dimension dim_Lie(d,m) ≪ d + d² + ... + dᵐ.\n\nArguments\n\nd::Int: Path dimension (d ≥ 1)\nm::Int: Truncation level (m ≥ 1)\n\nReturns\n\nBasisCache: Opaque structure containing basis information. Pass to logsig.\n\nPerformance Notes\n\nThis computation can be expensive for large d and m (involves symbolic shuffles).\nCache the result and reuse for multiple paths with the same (d, m).\nTime complexity: O(L²) where L is the number of Lyndon words.\n\nExamples\n\n# Precompute basis for 3D paths, level 5\nbasis = prepare(3, 5)\n\n# Reuse for multiple paths\nfor path in paths\n    ls = logsig(path, basis)\n    # process ls...\nend\n\nReferences\n\nReutenauer (1993). \"Free Lie Algebras.\" Oxford University Press.\n\nSee also: logsig, BasisCache\n\n\n\n\n\n","category":"function"},{"location":"api/#ChenSignatures.Tensor","page":"API Reference","title":"ChenSignatures.Tensor","text":"Tensor{T,D,M} <: AbstractTensor{T}\n\nDense tensor algebra element up to level M in dimension D.\n\nThis is the core data structure for representing truncated tensor series in the path signature computation. It stores coefficients for all tensor levels from 0 to M in a single flat array with efficient memory layout.\n\nType Parameters\n\nT: Element type (e.g., Float64, Float32)\nD: Dimension (number of coordinate axes)\nM: Maximum truncation level\n\nFields\n\ncoeffs::Vector{T}: Flattened coefficient array containing all levels 0 through M. Length is 1 + D + D² + ... + Dᴹ⁺¹ (includes padding for alignment).\noffsets::Vector{Int}: Starting indices for each level in coeffs. Length M+2.\n\nConstruction\n\n# Create zero tensor\nt = Tensor{Float64, 3, 4}()\n\n# Create from coefficient vector\ncoeffs = randn(len)  # Must match expected length\nt = Tensor{Float64, 3, 4}(coeffs)\n\nNotes\n\nMost users should use sig instead of working with Tensor directly.\nFor advanced applications requiring direct tensor manipulation, see signature_path!.\nThe type parameters {T,D,M} are compile-time constants, enabling aggressive optimization.\n\nSee also: sig, signature_path, SignatureWorkspace\n\n\n\n\n\n","category":"type"},{"location":"api/#ChenSignatures.SignatureWorkspace","page":"API Reference","title":"ChenSignatures.SignatureWorkspace","text":"SignatureWorkspace{T,D,M}\n\nPreallocated workspace for computing path signatures without allocations.\n\nThis workspace contains scratch buffers used internally by the Horner update scheme. Reusing a workspace across multiple signature computations eliminates memory allocations in the hot path, which is beneficial for batch processing or moving window applications.\n\nType Parameters\n\nT: Element type (e.g., Float64, Float32)\nD: Path dimension (number of coordinates per point)\nM: Truncation level (maximum signature level to compute)\n\nFields\n\nB1::Vector{T}: First scratch buffer of length D^(M-1)\nB2::Vector{T}: Second scratch buffer of length D^(M-1)\n\nExample\n\n# Create workspace for dimension 3, level 4\nws = SignatureWorkspace{Float64, 3, 4}()\n\n# Reuse workspace for multiple paths\nfor path in paths\n    out = Tensor{Float64, 3, 4}()\n    signature_path!(out, path, ws)\n    # process out...\nend\n\nSee also: signature_path!\n\n\n\n\n\n","category":"type"},{"location":"api/#ChenSignatures.BasisCache","page":"API Reference","title":"ChenSignatures.BasisCache","text":"BasisCache{T}\n\nCached Lyndon basis data for efficient log-signature computation.\n\nThis structure stores precomputed data for projecting signatures onto the Lyndon basis, which provides a minimal free-Lie algebra representation of the log-signature.\n\nFields\n\nd::Int: Path dimension\nm::Int: Truncation level\nlynds::Vector{Word}: Lyndon words up to length m\nL::Matrix{T}: Lower-triangular projection matrix\n\nNotes\n\nCreate instances using prepare, not directly.\n\nSee also: prepare, logsig\n\n\n\n\n\n","category":"type"},{"location":"api/#ChenSignatures.signature_path","page":"API Reference","title":"ChenSignatures.signature_path","text":"signature_path(::Type{Tensor{T}}, path, m::Int) -> Tensor{T,D,m}\n\nCompute path signature and return as a Tensor (not flattened).\n\nThis is a lower-level function that returns the signature in tensor form rather than as a flattened vector. Most users should use sig instead.\n\nArguments\n\n::Type{Tensor{T}}: Element type for the output tensor\npath: Path as AbstractMatrix{T} or AbstractVector{SVector{D,T}}\nm::Int: Truncation level\n\nReturns\n\nTensor{T,D,m}: Signature tensor with graded structure preserved\n\nSee also: sig, signature_path!\n\n\n\n\n\n","category":"function"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Thank you for your interest in ChenSignatures.jl!","category":"section"},{"location":"contributing/#Reporting-Issues","page":"Contributing","title":"Reporting Issues","text":"We welcome bug reports, feature requests, and suggestions:\n\nGitHub Issues: https://github.com/aleCombi/ChenSignatures.jl/issues\n\nWhen reporting an issue, please include:\n\nJulia version (julia --version)\nChenSignatures.jl version\nMinimal reproducible example\nError messages or unexpected behavior","category":"section"},{"location":"contributing/#Feature-Suggestions","page":"Contributing","title":"Feature Suggestions","text":"If you have ideas for new features or improvements, please open an issue describing:\n\nThe use case or problem you're trying to solve\nYour proposed solution or approach\nAny relevant references or examples from other libraries","category":"section"},{"location":"contributing/#Pull-Requests","page":"Contributing","title":"Pull Requests","text":"Pull requests are not currently being accepted.\n\nThe project is in active development, and the maintainer is focusing on core features and stability. However, your feedback and suggestions via issues are highly valued and will inform future development.","category":"section"},{"location":"contributing/#Questions-and-Discussion","page":"Contributing","title":"Questions and Discussion","text":"For general questions or discussion:\n\nOpen a GitHub issue with the \"question\" label\nProvide context about what you're trying to accomplish","category":"section"},{"location":"contributing/#Code-of-Conduct","page":"Contributing","title":"Code of Conduct","text":"Please be respectful and constructive in all interactions. We aim to maintain a welcoming and inclusive community.","category":"section"},{"location":"#ChenSignatures.jl","page":"Home","title":"ChenSignatures.jl","text":"ChenSignatures.jl is a high-performance Julia library for computing path signatures and log-signatures—core tools in Rough Path Theory, stochastic analysis, and modern machine learning.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package efficiently computes:\n\nSignatures: Truncated iterated integrals up to any level\nLog-signatures: Compact representations using Lyndon bases\nBatch processing: Multi-threaded computation of multiple paths\nAutomatic differentiation: Full gradient support via ChainRulesCore and Enzyme\n\nPath signatures are widely used in financial time series, Neural CDEs, stochastic analysis, and machine learning feature engineering.\n\n","category":"section"},{"location":"#What-is-a-Path-Signature?","page":"Home","title":"What is a Path Signature?","text":"Given a path gamma  0T to mathbbR^d, the signature S(gamma) is the collection of iterated integrals:\n\nS(gamma) = left(1 S^(1)(gamma) S^(2)(gamma) ldots S^(m)(gamma)right)\n\nwhere each level k contains d^k tensor coefficients:\n\nS^(k)_i_1 ldots i_k(gamma) = int_0  t_1  cdots  t_k  T dgamma^i_1_t_1 cdots dgamma^i_k_t_k\n\nFor discrete paths, these are computed recursively using Chen's identity:\n\nS(gamma_st) = S(gamma_su) otimes S(gamma_ut)\n\nKey property: Signatures uniquely characterize paths up to tree-like equivalence and are naturally invariant to time reparametrization.\n\n","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Computing-Signatures","page":"Home","title":"Computing Signatures","text":"using ChenSignatures\n\n# Create a 2D path with 100 points\npath = randn(100, 2)\n\n# Compute signature up to level 4\ns = sig(path, 4)\n\n# Output is a flattened vector: length = 2 + 4 + 8 + 16 = 30\nlength(s)  # 30","category":"section"},{"location":"#Computing-Log-Signatures","page":"Home","title":"Computing Log-Signatures","text":"The log-signature is the logarithm of the signature projected onto the Lyndon basis, providing a minimal representation:\n\n# Precompute Lyndon basis (dimension=3, level=4)\nbasis = prepare(3, 4)\n\n# Generate a 3D path\npath = randn(50, 3)\n\n# Compute log-signature\nls = logsig(path, basis)\n\n# Log-signature is more compact than full signature\nprintln(\"Log-signature length: \", length(ls))\nprintln(\"Full signature would be: \", 3 + 9 + 27 + 81, \" coefficients\")\n\nTip: Reuse the basis for multiple paths with the same dimension and truncation level.","category":"section"},{"location":"#Batch-Processing","page":"Home","title":"Batch Processing","text":"Process multiple paths efficiently with built-in batching:\n\n# Batch of 100 paths, each 50×3 (50 points, 3 dimensions)\npaths = randn(50, 3, 100)\n\n# Compute all signatures at once with multi-threading\nsigs = sig(paths, 4)  # Returns matrix of size (signature_length, 100)\n\n# Or log-signatures\nbasis = prepare(3, 4)\nlogsigs = logsig(paths, basis, threaded=true)\n\n","category":"section"},{"location":"#Python-Wrapper","page":"Home","title":"Python Wrapper","text":"A Python package chen-signatures provides the same high-performance functionality via juliacall:\n\npip install chen-signatures\n\nimport chen\nimport numpy as np\n\npath = np.random.randn(1000, 10)\nsignature = chen.sig(path, m=5)\n\nResources:\n\nPyPI: https://pypi.org/project/chen-signatures/\nPython Documentation: python/README.md\n\nThe Python wrapper supports NumPy arrays, PyTorch integration with autograd, and maintains the same performance characteristics as the Julia implementation.\n\n","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"ChenSignatures.jl is highly performant with optimizations for long paths, high dimensions, and deep truncation levels.\n\nBenchmarks: Comprehensive comparisons against iisignature and pysiglib are available at:\n\naleCombi/sig-benchmarks\n\nReproducible benchmark results and detailed performance analysis will be published in the future.\n\n","category":"section"},{"location":"#Automatic-Differentiation","page":"Home","title":"Automatic Differentiation","text":"Full support for automatic differentiation:\n\nusing ChenSignatures\nusing Zygote\n\npath = randn(50, 3)\n\n# Gradient with respect to path\ngrad = gradient(p -> sum(sig(p, 4)), path)\n\nBoth ChainRulesCore and Enzyme.jl integration are provided.\n\n","category":"section"},{"location":"#Links","page":"Home","title":"Links","text":"Julia Package: GitHub Repository\nJulia README: README.md\nPython Package: PyPI\nPython README: python/README.md\nBenchmarks: sig-benchmarks\n\n","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"@software{chen_signatures,\n  author = {Combi, Alessandro},\n  title = {ChenSignatures.jl: High-performance signatures and log-signatures},\n  year = {2025},\n  url = {https://github.com/aleCombi/ChenSignatures.jl}\n}\n\n","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Path Signatures and Rough Path Theory:\n\nK.T. Chen (1957). \"Integration of paths, geometric invariants and a generalized Baker-Hausdorff formula.\"\nT. Lyons, M. Caruana, T. Lévy (2007). \"Differential equations driven by rough paths.\" Lecture Notes in Mathematics, Springer.\n\nLyndon Basis:\n\nC. Reutenauer (1993). \"Free Lie Algebras.\" Oxford University Press.","category":"section"}]
}
