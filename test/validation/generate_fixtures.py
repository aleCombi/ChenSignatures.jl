import numpy as np
import iisignature
import math
from pathlib import Path

# Script is in ChenSignatures.jl/test/validation/
SCRIPT_DIR = Path(__file__).resolve().parent

# Output is in ChenSignatures.jl/test/fixtures.jl
OUTPUT_PATH = SCRIPT_DIR.parent / "fixtures.jl"

# -------- Path Generators --------

def make_path_linear(d: int, N: int) -> np.ndarray:
    """Generate linear path: [t, 2t, 2t, ...]"""
    ts = np.linspace(0.0, 1.0, N)
    path = np.empty((N, d), dtype=float)
    path[:, 0] = ts
    if d > 1:
        path[:, 1:] = 2.0 * ts[:, None]
    return path

def make_path_sin(d: int, N: int) -> np.ndarray:
    """Generate sinusoidal path: [sin(2π·1·t), sin(2π·2·t), ...]"""
    ts = np.linspace(0.0, 1.0, N)
    omega = 2.0 * math.pi
    # Matches Julia: path[i, k] = sin(2pi * t * k)
    # Python array is 0-indexed, so k=1..d maps to cols 0..d-1
    ks = np.arange(1, d + 1, dtype=float)
    path = np.sin(omega * ts[:, None] * ks[None, :])
    return path

def make_path(d: int, N: int, kind: str) -> np.ndarray:
    """Generate path of specified kind"""
    if kind == "linear":
        return make_path_linear(d, N)
    elif kind == "sin":
        return make_path_sin(d, N)
    else:
        raise ValueError(f"Unknown path_kind: {kind}")

def fmt_array(arr):
    # Format numpy array as a Julia Vector
    # Use high precision
    items = [f"{x:.17e}" for x in arr.ravel()]
    return "[" + ", ".join(items) + "]"

def generate():
    print(f"Generating fixtures to: {OUTPUT_PATH}")
    
    with open(OUTPUT_PATH, "w", encoding="utf-8") as f:
        def w(text=""):
            f.write(text + "\n")

        w("# This file is auto-generated by test/validation/generate.py")
        w("# Do not edit manually.")
        w("module Fixtures")
        w()
        
        # Configuration for the snapshot
        N = 10
        configs = [
            (2, 4, "linear"),
            (2, 4, "sin"),
            (3, 3, "linear"),
        ]

        w(f"const N = {N}")
        w()

        for d, m, kind in configs:
            path = make_path(d, N, kind)
            
            # 1. Signature
            sig = iisignature.sig(path, m)
            name_sig = f"SIG_D{d}_M{m}_{kind.upper()}"
            w(f"const {name_sig} = {fmt_array(sig)}")

            # 2. Log Signature (Lyndon Basis)
            # Note: iisignature.logsig requires prepared basis for correctness
            basis = iisignature.prepare(d, m)
            logsig = iisignature.logsig(path, basis)
            name_log = f"LOGSIG_D{d}_M{m}_{kind.upper()}"
            w(f"const {name_log} = {fmt_array(logsig)}")
            w()

        w("end # module")
    
    print("Done.")

if __name__ == "__main__":
    generate()